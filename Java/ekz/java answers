/*
Определение 1. Объект (object) – это самоописывающая
структура данных, обладающая внутренним состоянием и
способная обрабатывать передаваемые ей сообщения.
В языках программирования со статической проверкой (в
частности, в Java) набор сообщений, которые может обрабатывать объект, фиксирован на этапе компиляции программы. При этом передача объекту сообщения, которое он не
может обработать, выявляется на этапе компиляции.
Определение 2. Инкапсуляция (incapsulation) – один из
основных принципов объектно-ориентированного программирования, заключающийся в том, что доступ к внутреннему состоянию объекта извне осуществляется только через
механизм передачи сообщений.

Объект является самоописывающей структурой, потому что
содержит информацию о классе, которому он принадлежит.
Определение 3. Класс (class) – это тип данных, значениями которого являются объекты, имеющие сходное внутреннее состояние и обрабатывающие одинаковый набор сообщений.
Класс можно рассматривать как шаблон для порождения
объектов. Поэтому объекты называют также экземплярами
класса (class instances).
В языке Java все значения являются объектами, кроме значений примитивных типов: char (16-разрядный символ
Unicode), byte (знаковый, 8 бит), short (знаковый, 16 бит),
int (знаковый, 32 бит), long (знаковый, 64 бит), float,
double, boolean.
Обратите внимание, все целые типы – знаковые.

В языке Java классы делятся на публичные и непубличные.
В каждом java-файле должен быть ровно один публичный
класс, причём имя файла должно совпадать с именем класса. Непубличных классов в файле может быть несколько.
Непубличные классы видны только в пределах того файла,
где они объявлены.

экземплярные поля – обеспечивают хранение внутреннего состояния объектов;
статические поля – предназначены для хранения данных, общих для всех объектов класса;
экземплярные методы – отвечают за обработку передаваемых объекту сообщений;
статические методы – выполняют действия, для которых не нужен доступ к конкретному объекту класса;
экземплярные конструкторы – инициализируют только что созданные объекты класса;
статический конструктор (набор static-блоков) – инициализирует статические поля класса;
вложенные классы – главным образом, представляют
объекты, необходимые для реализации данного класса

В общем случае, для доступа к членам класса используется
бинарная операция «.». Её первый операнд – либо объект,
либо класс, а второй операнд – имя члена класса.

private доступ разрешён только из тела класса;
без модификатора доступ разрешён для самого класса и
для классов из того же пакета.
protected доступ разрешён для самого класса, для классов из того же пакета, а также для наследников класса
(пакеты и наследование мы рассмотрим позже);
public доступ возможен откуда угодно.

Определение 4. Экземплярное поле (instance field) – именованная составная часть внутреннего состояния объекта.
В Java объявления экземплярных полей выглядят как объявления полей структур в языке C. При этом каждое объявление предваряется модификатором доступа.
Определение 5. Статическое поле (static field), принадлежащее некоторому классу – это поле, разделяемое всеми
объектами этого класса.

Определение 6. Экземплярный метод (instance method) –
это подпрограмма, осуществляющая обработку переданного
объекту сообщения.
Передача объекту сообщения сводится к вызову соответствующего экземплярного метода.
Экземплярный метод имеет доступ к внутреннему состоянию объекта, то есть может читать и изменять значения
экземплярных полей объекта.
Доступ к внутреннему состоянию объекта обеспечивается за
счёт передачи в экземплярный метод ссылки (т.е. указателя) на объект. В Java эта ссылка передаётся неявно и имеет
имя this.

Определение 7. Статический метод (static method), объявленный в некотором классе – это метод, не имеющий доступа к внутреннему состоянию объектов этого класса.

Определение 8. Сигнатура метода (method signature) –
это информация о количестве и типах формальных параметров метода.
Если у метода нет формальных параметров, говорят, что он
имеет пустую сигнатуру.
Определение 9. Перегрузка метода (method overloading) –
это объявление для заданного класса двух или более методов, имеющих одинаковое имя, но различные сигнатуры.
Решение о том, куда именно передаётся управление при вызове перегруженного метода X, принимается на этапе компиляции на основе сопоставления типов фактических параметров вызываемого метода и сигнатур методов, имеющих
имя X.

Определение 10. Раннее связывание (early binding) – это
определение адреса вызываемого экземплярного метода во
время компиляции программы.
Определение 11. Позднее связывание (late binding) – это
определение адреса вызываемого экземплярного метода на
основе информации о классе объекта во время выполнения
программы.
Определение 12. Экземплярные методы, для вызовов которых выполняется позднее связывание, называются виртуальными (virtual methods).
В языке Java все методы – виртуальные.

Определение 13. Экземплярный конструктор (instance
constructor) – это экземплярный метод, предназначенный
для инициализации только что созданного объекта.
Инициализация объекта главным образом заключается в
заполнении информации о классе, которому принадлежит
объект.
В Java и других объектно-ориентированных языках операция создания объекта, как правило, объединена с вызовом
конструктора. Это гарантирует отсутствие неинициализиро
- ванных объектов.

В некоторых языках конструкторы имеют имена (Object
Pascal), но чаще всего конструкторы фактически безымянны (C++, C#, Java, Ruby). Конструкторы, как и всякие методы, могут быть перегружены.
Определение 14. Конструктор по умолчанию (default
constructor) – это экземплярный конструктор с пустой сигнатурой.
Во всех языках программирования конструктор по умолчанию автоматически создаётся компилятором, если для
класса не определён ни один конструктор.

В Java объекты, в отличие от значений примитивных типов,
могут располагаться только в динамической памяти (куче).
Кроме того, объекты не могут вкладываться друг в друга.
Другими словами, объекты не могут лежать в локальных
переменных и параметрах методов, в полях объектов и элементах массивов. Вместо этого там хранятся только указатели на объекты, которые в языке Java называются объектными ссылками.

Определение 15. Статический конструктор (static
constructor) – это статический метод, предназначенный для
инициализации статических полей класса. Статический конструктор не имеет параметров и вызывается до вызова любого статического метода или конструктора класса.

«Static»-блоки выполняются при первом обращении к классу, где под обращением к классу мы будем понимать создание объекта, вызов статического метода, обращение к статическому полю и т.д.
Если объявление класса содержит несколько «static»-
блоков, то они будут выполняться в том порядке, в котором
они перечислены в теле класса. Совокупность всех «staticблоков» класса играет роль статического конструктора.

Определение 16. Тип данных
A является подтипом
(subtype) для типа данных
B, если программный код,
расчитанный на обработку значений типа
B, может быть
корректно использован для обработки значений типа
A.
Определение 17. Субтипизация (subtyping) – это свойство языка программирования, означающее возможность
использования подтипов в программах.
Для лучшего понимания субтипизации можно рассматривать тип данных как множество значений. Тогда тип
A является подтипом для типа
B, если
A
⊆
B.
Семантика языков, поддерживающих субтипизацию и ориентированных на статическую проверку, допускает, что одно
значение может иметь сразу несколько типов. (Действительно, значение может принадлежать сразу нескольким множествам.)

В языке программирования, поддерживающем неявную субтипизацию, решение о том, является ли тип
A подтипом
для типа
B, принимается на основе анализа структуры значений этих типов. Поэтому неявную субтипизацию часто называют структурной субтипизацией (structural subtyping).

В языке программирования, поддерживающим явную субтипизацию (explicit subtyping или nominal subtyping), тип
A
является подтипом для типа
B тогда и только тогда, когда
A является наследником
B.

Java - явная субтипизация

Определение 18. Наследование (inheritance) – это способ получения нового класса на основе уже существующего
класса, сочетающий усложнение внутреннего состояния объектов, расширение ассортимента обрабатываемых сообщений и изменение реакции на некоторые сообщения.
Если новый класс
A создан на основе уже существующего
класса
B с помощью механизма наследования, то говорят,
что класс
A является производным классом (derived class)
или подклассом (subclass) по отношению к классу
B. В свою
очередь, класс
B выступает в роли базового класса (base
class) или суперкласса (superclass) для класса
A.
При наследовании производный класс получает все экземплярные поля базового класса и все экземплярные методы, кроме конструкторов. Тело любого конструктора производного класса должно начинаться с вызова одного из
конструкторов базового класса.

Определение 19. Одиночное наследование (single
inheritance) – это вариант наследования, при котором у
класса не может быть более одного базового класса.
По умолчанию класс является наследником встроенного
класса Object.

Операция динамического приведения объектной ссылки obj
к типу
T проверяет, является ли тип
T одним из типов объекта obj, и возвращает obj, если является. В противном случае операция порождает исключение ClassCastException. В
Java динамическое приведение записывается как (тип)obj.

Определение 20. Переопределение метода (method
overriding) – это замена тела экземплярного метода базового класса в производном классе, позволяющая объекту
производного класса по-другому обрабатывать то же самое
сообщение.

Следует хорошо понимать разницу между переопределением и перегрузкой метода: при переопределении в классе не
появляется новый метод, но изменяется реализация метода,
унаследованного от базового класса.
Переопределение метода возможно только в случае, если
для вызова этого метода используется позднее связывание,
то есть если метод – виртуальный. Так как в языке Java все
методы – виртуальные, то любой метод может быть переопределён.
В для переопределения метода, унаследованного от базового класса, достаточно объявить этот метод в производном
классе.

Определение 21. Абстрактный метод (abstract method) –
это не имеющий тела виртуальный метод, который должен
быть переопределён в производных классах.

Определение 22. Абстрактный класс (abstract class) – это
класс, имеющий абстрактные методы, которые либо объявлены в нём самом, либо унаследованы от базовых классов и
не переопределены.

Определение 23. Интерфейс (interface) – это тип данных,
представляющий собой набор абстрактных методов.
Предназначение интерфейса – служить контрактом между
разработчиком некоторого класса и разработчиком кода,
использующего данный класс.
Аналог интерфейса – чистый абстрактный класс, в котором
отсутствуют экземплярные поля и неабстрактные экземплярные методы. Создание экземпляров интерфейсов невозможно.

Определение 24. Реализация интерфейса (interface
implementation) – это класс, являющийся подтипом этого интерфейса. Если этот класс – неабстрактный, то в нём
должны быть определены все без исключения методы интерфейса.
Класс может реализовывать сразу несколько интерфейсов.
Тем самым, в Java интерфейсы частично компенсируют отсутствие множественного наследования. Синтаксически в
Java реализуемые классом интерфейсы перечисляются после
ключевого слова implements.
Интерфейс может быть наследником других интерфейсов,
которые перечисляются в его объявлении после ключевого
слова extends.

Определение 25. Класс
X называется экземплярным вложенным классом (inner class) в классе
Y , если из методов
класса
X доступно внутреннее состояние объекта класса
Y .
При этом класс
Y называется объемлющим классом.

Определение 26. Класс
X называется статическим вложенным классом (static nested class) в классе
Y , если из
методов класса
X доступны статические поля класса
Y .

Определение 27. Локальный класс (local class) – экземплярный вложенный класс, объявленный внутри метода
объемлющего класса и имеющий доступ к неизменяемым
локальным переменным и параметрам этого метода.

Определение 28. Анонимный класс (anonymous class) –
локальный класс, объявление которого совмещено с созданием его экземпляра.
Для объявления анонимного класса и создания его экземпляра используется специальная форма операции new:

Определение 29. Функциональный интерфейс (functional
interface) – интерфейс с единственным абстрактным методом.
Создание экземпляра анонимного класса, реализующего
функциональный интерфейс, синтаксически может быть
представлено в виде /emphлямбда-выражения, имеющего
две формы:
1. ( форм . параметры ) -> тело_метода
2. ( форм . параметры ) -> выражение
interface IntBinaryExpr {
int eval ( int x , int y );
}
public class Test {
public static void main ( String [] args ) {
IntBinaryExpr e = (x , y) -> x + y;

Определение 30. Контейнерный класс – это класс, объекты которого выступают в роли хранилищ других объектов.

import java . util . Arrays ;

 public class Stack {
 private int count = 0;
 private Object [] buf = new Object [16];

 public boolean empty () { return count == 0; }

 public void push ( Object x ) {
 if ( count == buf . length )
 buf = Arrays . copyOf ( buf , buf . length *2);
 buf [ count ++] = x;

}

 public Object pop () {
 if ( empty ())
 throw new RuntimeException (" underflow " );
 return buf [-- count ];

}

}

Определение 31. Обобщённый класс – это класс, имеющий
формальные типовые параметры.
Определение 32. Формальный типовый параметр – это
тип, который используется в объявлении обобщённого класса и при этом неизвестен во время компиляции обобщённого
класса.
Типовые параметры в объявлении обобщённого класса перечисляются в угловых скобках после имени класса

import java . util . Arrays ;

 public class Stack <T > {
 private int count = 0;
 private Object [] buf = new Object [16];

 public boolean empty () { return count == 0; }

 public void push ( T x) {
 if ( count == buf . length )
 buf = Arrays . copyOf ( buf , buf . length *2);
 buf [ count ++] = x;

}

 @SuppressWarnings (" unchecked ")
 public T pop () {
 if ( empty ())
 throw new RuntimeException (" underflow " );
 return (T) buf [-- count ];

}

}
Stack < Integer > s = new Stack < Integer >();
s. push (1); s . push (2); s. push (3);
int sum = 0;
while (! s. empty ()) {
int x = s . pop ();
sum += x;
}

Определение 33. Ограниченный обобщённый класс – это
обобщённый класс, хотя бы для одного формального типового параметра которого задана верхняя граница.
class Имя <... , параметр extends X , ... > огранич сверху
G <... , ? super X , ... > огранич снизу

Дело в том, что обобщённые классы в Java инвариантны,
т.е. если
G – обобщённый класс, и класс
S – наследник класса
T, то классы G<S>
и G<T> отношением наследования не
связаны.
Отметим, однако, что если, например, DerivedStack<T>
– наследник Stack<T>, то DerivedStack<Integer> – наследник
Stack<Integer>.

Определение 34. Шаблон обобщённого класса
G – это
неявный супертип для любого класса, порождённого из
G.
Шаблон получается параметризацией класса
G специальным
фактическим параметром «
?».

Определение 35. Обобщённый метод – это статический
или экземплярный метод класса, имеющий формальные типовые параметры
Определение 36. Нештатная ситуация – это ситуация, в
которой выполнение некоторого фрагмента кода программы
оказывается по тем или иным причинам невозможно.
Определение 37. Исключительная ситуация – это
нештатная ситуация, возникшая в силу внешних по отношению к программе причин.
Примеры: не открылся файл, произошло незапланированное
закрытие сетевого соединения.
Определение 38. Ошибочная ситуация – это нештатная
ситуация, возникшая из-за ошибки в коде программы.
Определение 39. Перехват нештатных ситуации – это
механизм, обеспечивающий продолжение работы программы
при возникновении нештатной ситуации.
try
{ // try - блок
/* код , в котором может возникнуть
нештатная ситуация */
...
}
catch ( SomeException e) { // catch - блок
/* обработчик исключений , которые можно привести
к типу SomeException */
...
}
catch ( SomeException2 e) { // catch - блок
...
}
... /* другие catch - блоки */ ...
finally
{ // finally - блок
/* код , который должен вызываться
при любом выходе из try - блока */
...
}

Определение 41. Функтор – это обобщённый класс, параметризованный типом T и инкапсулирующий значение(-я)
типа T, удовлетворяющий следующим условиям:
 объекты функтора – неизменяемые;
 у функтора имеется метод map, получающий в качестве
параметра функцию (т.е. лямбда-выражение) преобразования значений типа T;
 метод map применяет функцию к значению(-ям),
лежащему(-им) внутри функтора, и возвращает новый объект функтора, в котором инкапсулирован(-ы)
результат(-ы) применения функции;
 если передать методу map функцию, которая просто возвращает значение своего аргумента (функцияидентичность), то единственным эффектом вызова метода map будет порождение объекта функтора, идентичного исходному объекту.


-------ФУНКТОР-------

public class Roots <T > {
private HashSet <T > container ;
private Roots ( HashSet <T > container ) {
this . container = container ;
}
public static Roots < Double > of (
double a , double b , double c , double eps ){
HashSet < Double > roots = new HashSet < >();
if (a == 0.0) {
if (b != 0.0) roots . add (- c/b );
} else
{
double d = b*b - 4* a*c;
if (d >= 0.0) {
if (d < eps ) d = 0.0;
roots . add (( - b + Math . sqrt (d )) / (2* a ));
roots . add (( -b - Math . sqrt (d )) / (2* a ));
}
}
return new Roots < >( roots );
}
public <R > Roots <R > map ( Function <T , R > f) {
HashSet <R > c = new HashSet < >();
for ( T t : container ) c. add (f . apply (t ));
return new Roots < >( c );
}
public void forEach ( Consumer <T > f ) {
for ( T t : container ) f. accept (t );
}
}

----Главный ФАЙЛ------
public class Point {
private double x , y;
public Point ( double x , double y) {
this .x = x;
this .y = y;
}
public double dist () {
return Math . sqrt (x*x + y*y );
}
public String toString () {
return String . format ( " (% f ,␣%f )" , x , y );
}
}

Избавиться от обозначенной на предыдущем слайде проблемы можно, превратив функтор Roots
в монаду путём
добавления метода flatMap:
public class Roots <T > {
...
public <R > Roots <R > flatMap (
Function <T , Roots <R >> f) {
HashSet <R > c = new HashSet < >();
map (f ). forEach ( rs -> c. addAll ( rs . container ));
return new Roots < >( c );
}
...
}
Метод flatMap «уплощает» корни, объединяя множества
корней из нескольких объектов класса Roots в одно множество.

Выводы, которые можно сделать из примера:
 функторы и монады предназначены для лаконичной записи последовательности преобразований данных;
 лаконичность записи достигается сокрытием громоздких управляющих конструкций языка Java (операторов
выбора и циклов) внутри методов функторов и монад;
 благодаря тому, что функторы и монады, а также их
методы – обобщённые, в процессе преобразований может
меняться тип данных
Определение 42. Монада – это функтор с дополнительным методом flatMap, удовлетворяющий следующим условиям:
 метод flatMap получает в качестве параметра функцию,
способную преобразовать каждое значение внутри монады и завернуть результат преобразования в новый
объект-монаду;
 метод flatMap применяет функцию ко всем значениям,
хранящимся внутри монады, и объединяет получившиеся объекты-монады в один объект;
 метод flatMap ассоциативен, т.е. выражение
m. flatMap (f ). flatMap ( g)
эквивалентно выражению
m. flatMap (x -> f(x ). flatMap (g ))
Объект монады Optional<T> является контейнером для нуля или одного объекта класса
T.
Подразумевается, что объект Optional<T> находится в одном из двух состояний:
 является пустым;
 содержит ненулевую ссылку на объект класса
T.
Создание объекта Optional<T>:
 создание пустого объекта:
static <T > Optional <T > empty ()
 заворачивание ненулевой объектной ссылки:
static <T > Optional <T > of (T value )
 заворачивание объектной ссылки с порождением пустого
объекта, если ссылка – нулевая:
static <T > Optional <T > ofNullable (T value )
«Развернуть» объект Optional<T> можно с путём вызова
метода get:
T get ()
В случае пустого объекта метод get порождает исключение
NoSuchElementException.
Перед вызовом метода get следует убедиться, что объект
Optional<T> – непустой, с помощью метода isPresent:
boolean isPresent ()


Метод map класса Optional<T> позволяет обойтись без проверок при записи композиции частичных функций:
<U > Optional <U > map (
Function <? super T , ? extends U > mapper )
Метод map принимает лямбда-выражение, определяющее
частичную функцию (она может возвращать null).
Схема работы метода map:
 если объект Optional<T> пустой, то метод map ничего не
делает и просто возвращает пустой Optional<U>.
 в противном случае значение, записанное в объекте
Optional<T>, передаётся в лямбда-выражение, и метод
map возвращает Optional<U>, в который «завёрнут» результат вычисления лямбда-выражения.
 результат «заворачивается» по принципу работы метода ofNullable, т.е. если он представляет собой нулевую
ссылку, то Optional<U> будет пустым.

Интерфейс Stream<T> в каком-то смысле является развитием идеи итераторов, т.е. представляет последовательность
некоторых значений, называемую потоком.
Получить объект Stream<T> можно из объекта любого контейтерного класса стандартной библиотеки языка Java путём вызова метода stream:
Stream <T > stream ()
Вытащить все значения из потока Stream<T> можно с помощью метода forEach:
void forEach ( Consumer <? super T > action )
Этот метод получает в качестве параметра лямбдавыражение и вызывает его для каждого значения из последовательности, представляемой потоком.
Методы интерфейса Stream<T> позволяют преобразовывать
последовательности:
 формирование потока, содержащего только те элементы
исходного потока, которые удовлетворяют предикату:
Stream <T > filter ( Predicate <? super T > predicate )
 формирование потока, представляющего последовательность значений, получаемую путём вызова функции для
каждого элемента исходного потока:
<R > Stream <R > map (
Function <? super T , ? extends R > mapper )
 конкатенация потоков, получаемых путём вызова функции для каждого элемента исходного потока:
<R > Stream <R > flatMap (
Function <? super T ,
? extends Stream <? extends R >> mapper
)

Потребление значений из потоков выполняется так называемыми коллекторами – объектами классов, реализующими интерфейс Collector. Коллекторы предназначены для
выполнения анализа потоков и записи результатов реализуемых потоками преобразований в объекты контейнерных
классов.
Чтобы задействовать некоторый коллектор, следует вызвать
метод collect потока:
<R ,A > R collect ( Collector <? super T ,A ,R > collector )

----Пакеты----

Начиная с определённого размера программной системы,
для её структурирования начинает не хватать одной только
декомпозиции на классы и требуется механизм пакетов:
 образуются группы взаимосвязанных классов, которые
целесообразно как-то выделить в отдельные подсистемы
и ограничить доступность некоторых классов рамками
соответствующей подсистемы;
 возникает потребность упростить навигацию по исходным текстам программной системы (чтобы легче находить классы, которые по смыслу относятся к той или
иной подсистеме);
 появляются трудности с изобретением уникальных имён
классов (особенно в случае командной разработки).

Определение 43. Пакет – это контейнер классов, предоставляющий для них отдельное пространство имён и дополнительные возможности по управлению доступом.
Определение 44. Имя пакета – это непустая последовательность идентификаторов, разделённых точками.
Определение 45. Квалифицированное имя класса – это
имя, с помощью которого можно обращаться к публичному
классу извне пакета, которому этот класс принадлежит
Квалифицированные имена записываются как
имя_пакета . имя_класса
Классы, объявленные в файлах, в которых отсутствует директива package, считаются принадлежащими безымянному
пакету по умолчанию (default package).
Компилятор Java требует, чтобы файлы пакета размещались в файловой системе в каталоге, путь к которому относительно текущего каталога (в котором запущен компилятор) соответствовал имени пакета.
Например, файлы пакета ru.bmstu.iu9 должны находиться
в каталоге ru/bmstu/iu9.
Файлы, принадлежащие пакету по умолчанию, должны находиться в текущем каталоге.

Для того чтобы обратиться к классу, принадлежащему другому пакету, этот класс нужно импортировать. Существует
три способа импорта класса.
1. Использование квалифицированного имени. Например,
java . util . HashSet < String > a =
new java . util . HashSet < >();
2. Указание класса в директиве import:
import java . util . HashSet ; // в начале файла
...
HashSet < String > a = new HashSet < >();
3. Использование директивы import для импорта всех
классов пакета:
import java . util .*; // в начале файла
...
HashSet < String > a = new HashSet < >();

Для упрощения доступа к статическим членам классов существует специальная форма директивы import, позволяющая импортировать их в текущий файл:
import static имя_пакета . имя_класса . имя_члена ;
или
import static имя_пакета . имя_класса .*;
Например, вычисление значения cos
π
3 , без импорта статических членов класса Math выглядящее как
double l = Math . cos ( Math . PI /3);
можно переписать более лаконично:
import static java . lang . Math .*;
...
double l = cos ( PI /3);

*/